## ver 1.1 からの主な変更点
後方参照が書けるようになりました。
これは生成パターンの中でも除外パターンの中でも利用することができます。

ver 1.1 以前の構文と互換性があるので、ver 1.1 以前の Zatlin コードはそのまま使えます。

## 基本構文
Zatlin では、どのような様式の文字列を生成するかを「パターン」と呼ばれる構文で表現します。
`%` に続いてパターンを書き、最後に `;` を置くと、そのパターンに合致する文字列がランダムに出力されます。
```
% ("s" | "t" | "k") ("a" | "e" | "i") ("z" | "d");
```

変数名に続いて `=` を書き、さらにパターンを続けて最後に `;` を置くと、変数を定義することができます。
変数名としては、英数字か `_` から構成される文字列であって、先頭が数字でないものが利用できます。
定義した変数は別のパターンの中で使用することができます。
変数を定義する順番によって動作が変化することはなく、後の行で定義される変数を使うこともできます。
```
consonant = "s" | "t" | "k";
vowel = "a" | "e" | "i"
last_consonant = "z" | "d";
pattern = consonant vowel last_consonant;
% pattern;
```

`#` から行末まではコメントとして扱われ、処理に影響を与えません。
```
# ここはコメント
% ("s" | "t" | "k") ("a" | "e" | "i") ("z" | "d");  # コメント
# ここはコメント
```

行末もしくはコメントの直前の `;` に限り省略できます。
```
foo = "a" | "b"  # ← 省略可能
bar = "c" | "d"; baz = "e" | "f"
# ↑ 行中は省略できない
```

## パターン
### 文字列パターン
`"` で囲まれた文字列は文字列パターンになります。
文字列パターンは、常にその文字列自身を生成します。
```
% "abc";
# 「abc」という文字列が必ず生成される。
```

文字列パターン内で `"` という文字を使いたい場合は、バックスラッシュを前置して `\"` とエスケープしてください。
また、`\` という文字を使いたい場合も、`\\` とエスケープしてください。
```
% "\"\\n\"";
# 「"\n"」という文字列が必ず生成される。
```

文字列パターン内で `\u` に続いて 16 進 4 桁の数を続けることで、その Unicode コードポイントの文字を表すことができます。
```
% "\u00E9";
# 「é」という文字列が必ず生成される。
```

### 変数パターン
変数名はそのまま変数パターンとして使うことができます。
変数パターンは、変数定義の中身が生成する文字列と同様の文字列を生成します。
```
foo = "abc";  # 変数 foo の定義
% foo;
# 「abc」という文字列が必ず生成される。
```

同じパターン内に同名の変数パターンが複数回使われた場合、変数パターンが現れるごとに毎回文字列を生成します。
したがって、同名の変数パターンが同一の文字列を生成するとは限りません。
前に出てくるパターンが生成した文字列と同一の文字列を生成したい場合は、連続パターンの後方参照機能を利用してください。
```
foo = "a" | "b";
% foo foo;
# 「aa」か「ab」か「ba」か「bb」が等確率で生成される。
# 同名の変数パターンだからといって「aa」と「bb」だけが生成されるわけではない。
```

### 連続パターン
パターンをスペースで区切って並べると連続パターンになります。
連続パターンは、それを構成するパターンに従って順番に文字列を生成し、その結果を順に結合した文字列を生成します。
```
foo = "a" | "b";
% foo "x";
# 「ax」か「bx」が等確率で生成される。
```

連続パターンの要素が選択パターンか除外パターンの場合、前後を `(` と `)` で囲む必要があります。
```
% ("a" | "b") "x" ("c" | "d");  # 3 つの要素からなる連続パターン
# 「axc」か「axd」か「bxc」か「bxd」が等確率で生成される。
```

連続パターンの中で `&` の後に整数を続けた記号を書くことで、後方参照することができます。
例えば、`&1` と書くと、連続パターンの中の 1 番目のパターンが生成した文字列と同一の文字列が生成されます。
```
foo = "a" | "b";
% foo &1;
# 「aa」か「bb」が等確率で生成される。
```

なお、後方参照が参照するパターンは、後方参照自身が置かれている箇所より前になければなりません。
例えば、`&2` は 2 番目のパターンを参照するので、`&2` 自身は連続パターンの中の 3 番目以降にしか置くことができません。
それ以外の場所に後方参照が置かれた場合、エラー #2001 が発生します。
```
foo = "a" | "b";
% foo &2 ("x" | "y");  # エラー
```

### 選択パターン
パターンを `|` で区切って並べると選択パターンになります。
選択パターンは、それを構成するパターンのうちいずれかを等確率で 1 つ選び、選ばれたパターンに従って生成した文字列を生成します。
```
% "a" | "b" | "c";
# 「a」か「b」か「c」が等確率で生成される。
```

選択パターンを構成するパターンの後に数を記すことで、記した数の分だけそのパターンが選択されやすくなります。
例えば、`2` を記しておくと、そのパターンが選択される確率が他のものの 2 倍になります。
また、`0.5` を記しておくと、そのパターンが選択される確率は他のものの 0.5 倍になるので、逆に他のパターンに比べて選択されにくくなります。
```
% "a" 3 | "b" 2 | "c";
# 「a」は 3 倍,「b」は 2 倍生成されやすくなる。
# 結果的に 1/2 の確率で「a」, 1/3 の確率で「b」, 1/6 の確率で「c」が生成される。
```

### 除外パターン
選択パターンの後に `-` に続いて別のパターンを記すことで、除外パターンを作ることができます。
除外パターンは、まず前半の選択パターンに従って文字列を生成しますが、その文字列が `-` の後のパターンが生成し得る文字列を含んでいる場合、もう一度前半の選択パターンから文字列を生成し直します。
結果的に、`-` の後のパターンが生成し得る文字列は、この除外パターンによって生成されることがなくなります。
```
% "abc" | "pqr" | "xyz" - "p";
#「abc」と「pqr」と「xyz」のいずれかが等確率で生成された後、それが「p」を含む「pqr」だった場合はもう一度生成し直す。
# 結果的に「pqr」はこのパターンから生成されず、「abc」か「xyz」が等確率で生成される。
```

選択パターン部分からの生成し直しは、最大で 100 回まで行われます。
100 回生成し直しても除外パターン部分が生成し得ない文字列が得られなかった場合、エラー #2000 が発生します。
これは、例えばあり得るパターンが全て除外されてしまっているときに起こります。
```
% "ab" | "ac" | "bc" - "a" | "c";
# 前半部分で生成され得る「ab」か「ac」か「bc」はいずれも「a」と「c」を含んでいるので、常に再生成が試みられる。
# 結果的にエラーになる。
```

また、除外されない文字列が生成される確率が非常に低い場合も、エラー #2000 が発生して失敗に終わる可能性があります。
```
% "a" 1000000 | "b" 1 - "a";
# 1/1000001 の確率で除外設定されていない「b」が生成され得るが、確率が非常に低いので 100 回の試行ではほとんど生成されない。
# 結果的にほとんど必ずエラーになる。
```

### 境界パターン
除外パターンの除外部分では、`^` という特殊な記号を使うことができます。
`^` が連続パターンの先頭に書かれた場合は、その連続パターンが生成し得る文字列から始まる文字列のみが除外されます (生成し得る文字列が途中に含まれていても良いということになる)。
```
% "ab" | "ba" | "ca" - ^ "a" | "c";
# 「a」で始まるものか「c」を含むものが除外される。
# 結果的に「ba」だけが生成される。
```

`^` が連続パターンの末尾に書かれた場合は、その連続パターンが生成し得る文字列で終わる文字列のみが除外されます。
```
% "ab" | "ba" | "ca" - "a" ^;
# 「a」で終わるものが除外される。
# 結果的に「ab」だけが生成される。
```

`^` が連続パターンの先頭にも末尾に書かれた場合は、その連続パターンが生成し得る文字列と完全に一致する文字列のみが除外されます。
```
% "a" | "aa" | "aaa" - ^ "a" ^;
# 「a」のみが除外される。
# 結果的に「aa」と「aaa」が等確率で生成される。
```

この `^` は、生成されたパターンが除外されるかどうか調べるときに、文字列の前後の境界にマッチすると考えると分かりやすいかもしれません。

除外パターンの除外部分には任意のパターンが書けるので、もちろん変数パターンも使えます。
そこで、`^` を含むパターンを変数に定義しておいて、その変数を除外パターンの除外部分で使うこともできます。
```
start_with_vowel = ^ ("a" | "e" | "i" | "o" | "u");
% "abc" | "def" | "ijk" | "uvw" - start_with_vowel;
# 「def」のみが生成される。
```

なお、`^` を除外パターンの除外部分以外にも書くこともできますが、その場合は単に無視されます。
```
% ^ "a" | "b" ^ "c";
# 「a」と「bc」が等確率で生成される。
```

## より複雑な例
```
# 母音
V = "a" 5 | "e" 3 | "i" 2 | "o" 3 | "u" 2;
# 子音
sz = "s" | "z"; td = "t" | "d"; kg = "k" | "g"; fv = "f" | "v";
C = sz 3 | td 3 | kg 3 | fv 3 | ("n" | "h") 2;
# 半母音＋母音
SV = V 5 | ("y" | "w") V - "yi" | "w" ("u" | "o");
# 音節
# 「yi」と「wu」と「wo」は半母音なしと区別が難しいので除外
syllable_vowel = V 3 | SV C 2;
syllable_cons = C SV 5 | C SV C 2 | C SV C C 3 | C C SV 5 | C C SV C 2 | C C SV C C 3;
syllable_first = syllable_vowel | syllable_cons 3;
syllable_rest = syllable_cons;
# 難発音
# 「h」で終わる単語や調音位置が同じ文字の連続など
# 後で除外設定のために使う
hard_h = C "h" | "h" C | "h" ^;
hard_cons = sz sz | td td | kg kg | fv fv | (("n" | "h") &1);
hard = hard_h | hard_cons;
# 単語
word = syllable_first ("" | syllable_rest 3 | syllable_rest syllable_rest 5) - hard;
# メインパターン
% word;
```
生成例:
```
feve, neksvzutkek, sdo, si, otsokz, vonevsyad, o, usa, ozuho, vgedavuf,
fuzkoz, insgozvat, e, zvofs, aga, sanse, efdi, okisn, fakvkok, onvekyu,
sgekvisnyu, duztfti, dkostwi, vovso, adsofye, de, fkak, kvwidsaftne, dadve, fazuzyo,
kosguknagv, gatskzakwa, fakve, o, a, faswefak, fkahego, fe, azfkiftsfevz, hyadise,
o, gzesihof, azutza, gvyekfe, tof, nosidziz, dfutafa, navde, sasonsfid, atzadev
```

## 形式的な構文定義
拡張した BNF 記法で記します。
以下の `zatlin` が Zatlin コードの全体の定義です。
```
zatlin ::= blankOrBreak sentence+ blankOrBreak
sentence ::= definition | mainPattern | comment
definition ::= identifier blank '=' blank compound blank semicolon
mainPattern ::= '%' blank compound blank semicolon
compound ::= disjunction (blank '-' blank disjunction)?
disjunction ::= weightedSequence (blank '|' blank weightedSequence)*
weightedSequence ::= sequence (blank weight)?
sequence ::= (circumflex blank)? sequencePattern (blank circumflex)?
sequencePattern ::= quote | backref | identifier | '(' blank compound blank ')'
quote ::= '"' (quoteEscape | quoteContent)* '"'
quoteEscape ::= '\\' ('u' [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] | '\\' | '"')
quoteContent ::= [^\\"]
backref ::= '&' [0-9]+
circumflex ::= '^'
comment ::= '#' [^\n]* blankOrBreak
semicolon ::= ';' blankOrBreak | break blankOrBreak | (?= '#' | eof)
identifier ::= [a-zA-Z] [a-zA-Z0-9_]*
weight ::= [0-9]+ '.'? [0-9]* | '.' [0-9]+
blankOrBreak ::= [\s]*
blank ::= [^\S\n]*
break ::= "\n"
```

拡張した記号は以下の通りです。

- `foo*` ･･･ `foo` の 0 回以上の繰り返し
- `foo+` ･･･ `foo` の 1 回以上の繰り返し
- `foo?` ･･･ `foo` の 0 回以上 1 回以下の繰り返し (`foo` は省略可能)
- `[0-9]` など ･･･ 正規表現の文字クラス
- `(?= foo)` ･･･ `foo` の先読み