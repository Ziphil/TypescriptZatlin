## ver 1.1 からの主な変更点
後方参照が書けるようになりました。
これは生成パターンの中でも除外パターンの中でも利用することができます。

ver 1.1 以前の構文と互換性があるので、ver 1.1 以前の Zatlin コードはそのまま使えます。

## 基本構文
Zatlin では、どのような様式の文字列を生成するかを「パターン」と呼ばれる構文で表現します。
パターンの構文については、後で詳しく解説します。

`%` に続いてパターンを書き、最後に `;` を置くと、メインパターンを定義できます。
Zatlin の処理系はこのメインパターンに沿ってランダムに文字列を出力するため、必ずメインパターンを書く必要があります。
```
% "s" | "t" | "k";
```

変数名に続いて `=` を書き、さらにパターンを続けて最後に `;` を置くと、変数を定義することができます。
変数名としては、英数字か `_` から構成される文字列であって、先頭が数字でないものが利用できます。
定義した変数は別のパターンの中で使用することができます。
変数を定義する順番によって動作が変化することはなく、後の行で定義される変数を使うこともできます。
```
vowel = "a" | "e" | "i";
cons = "s" | "t" | "k";
last_cons = "z" | "d";
pattern = cons vowel last_cons;
% pattern;
```

`#` から行末まではコメントとして扱われ、処理に影響を与えません。
```
# ここはコメント
% ("s" | "t" | "k") ("a" | "e" | "i") ("z" | "d");  # コメント
# ここはコメント
```

行末もしくはコメントの直前の `;` に限り省略できます。
```
foo = "a" | "b"  # ← 省略可能
bar = "c" | "d"; baz = "e" | "f"  # 行中 (baz の直前) は省略できない
% foo
```

## パターン
### 文字列パターン
`"` で囲まれた文字列は文字列パターンになります。
文字列パターンは、常にその文字列自身を生成します。
```
% "abc";
# 「abc」という文字列が必ず生成される
```

文字列パターン内で `"` という文字を使いたい場合は、バックスラッシュを前置して `\"` とエスケープしてください。
また、`\` という文字を使いたい場合も、`\\` とエスケープしてください。
```
% "\"\\n\"";
# 「"\n"」という文字列が必ず生成される
```

文字列パターン内で `\u` に続いて 16 進 4 桁の数を続けることで、その Unicode コードポイントの文字を表すことができます。
直接入力しづらい特殊文字を記述するのに便利です。
```
% "\u00E9";
# 「é」という文字列が必ず生成される
```

### 変数パターン
変数名はそのまま変数パターンとして使うことができます。
変数パターンは、その変数に定義されているパターンが生成する文字列と同様の文字列を生成します。
```
foo = "abc";  # 変数 foo の定義
# foo は「abc」という文字列を必ず生成する文字列パターン
% foo;
# foo と同じく「abc」という文字列が必ず生成される
```

1 つのパターンの中で同名の変数パターンが複数回使われた場合、その変数パターンごとに毎回文字列を生成し直します。
したがって、同名の変数パターンが常に同一の文字列を生成するとは限りません。
前に出てくるパターンが生成した文字列と同一の文字列を生成したい場合は、後方参照パターンを利用してください。
```
foo = "a" | "b";
% foo foo;
# 「aa」か「ab」か「ba」か「bb」が等確率で生成される
# 同名の変数パターンだからといって「aa」と「bb」だけが生成されるわけではない
```

### 連続パターン
パターンをスペースで区切って並べると連続パターンになります。
連続パターンは、それを構成するパターンに従って順番に文字列を生成し、その結果を順に結合した文字列を生成します。
```
foo = "a" | "b";
# foo は「a」か「b」を等確率で生成する
% foo "x";
# foo によって文字列を生成した後に「x」を結合した文字列を生成する
# 結果的に「ax」か「bx」が等確率で生成される
```

連続パターンの要素が選択パターンか複合パターンの場合、前後を `(` と `)` で囲む必要があります。
```
% ("a" | "b") "x" ("c" | "d");  # 3 つの要素からなる連続パターン
# 「axc」か「axd」か「bxc」か「bxd」が等確率で生成される
```

### 後方参照パターン
連続パターンの中で `&` の後に整数を続けた記号を書くことで、後方参照することができます。
例えば、`&1` と書くと、連続パターンの中の 1 番目のパターンが生成した文字列と同一の文字列が生成されます。
```
foo = "a" | "b";
% foo &1;
# 「aa」か「bb」が等確率で生成される
```

なお、後方参照が参照するパターンは、その後方参照自身が置かれている箇所より前になければなりません。
例えば、`&2` は 2 番目のパターンを参照するので、`&2` 自身は連続パターンの中の 3 番目以降にしか置くことができません。
それ以外の場所に後方参照が置かれた場合、エラー #2001 が発生します。
```
foo = "a" | "b";
% foo &2 ("x" | "y");  # エラー
```

### 選択パターン
パターンを `|` で区切って並べると選択パターンになります。
選択パターンは、それを構成するパターンのうちいずれかを等確率で 1 つ選び、選ばれたパターンに従って生成した文字列を生成します。
```
% "a" | "b" | "c";
# 「a」か「b」か「c」が等確率で生成される
```

選択パターンを構成するパターンの後に数値を記すことで、その数値の分だけそのパターンが選択されやすくなります。
例えば、`2` を記しておくと、そのパターンが選択される確率が他のものの 2 倍になります。
また、`0.5` を記しておくと、そのパターンが選択される確率が他のものの 0.5 倍になるので、逆に他のパターンに比べて選択されにくくなります。
```
% "a" 3 | "b" 2 | "c";
# 「a」は 3 倍,「b」は 2 倍生成されやすくなる
# 結果的に 1/2 の確率で「a」, 1/3 の確率で「b」, 1/6 の確率で「c」が生成される
```

### 複合パターン
選択パターンの後に `-` に続いて別のパターンを記すことで、複合パターンを作ることができます。
複合パターンは、まず前半の選択パターンに従って文字列を生成しますが、その文字列が `-` の後のパターンが生成し得る文字列を含んでいる場合、もう一度前半の選択パターンから文字列を生成し直します。
結果的に、`-` の後のパターンが生成し得る文字列を含む文字列が、この複合パターン全体によって生成される文字列から除外されることになります。
そのため、`-` の後に書かれたパターンは「除外パターン」と呼ばれます。
```
% "abc" | "pqr" | "xyz" - "p";
# 「abc」と「pqr」と「xyz」のいずれかが等確率で生成された後で
# それが「p」を含む「pqr」だった場合はもう一度生成し直す
# 結果的に「pqr」はこのパターンから生成されずに「abc」か「xyz」が等確率で生成される
```

選択パターン部分からの生成し直しは、最大で 100 回まで行われます。
100 回生成し直しても除外パターン部分が生成し得ない文字列が得られなかった場合、エラー #2000 が発生します。
これは、例えばあり得るパターンが全て除外されてしまっているときに起こります。
```
% "ab" | "ac" | "bc" - "a" | "c";
# 前半部分で生成され得る「ab」か「ac」か「bc」はいずれも「a」と「c」を含んでいる
# したがって常に再生成が試みられる
# 結果的に複合パターンからの生成に失敗してエラーになる
```

また、除外されない文字列が生成される確率が非常に低い場合も、エラー #2000 が発生して失敗に終わる可能性があります。
```
% "a" 1000000 | "b" 1 - "a";
# 1/1000001 の確率で除外設定されていない「b」が生成され得る
# しかし「b」の確率が非常に低いので 100 回の試行ではほとんど生成されない
# 結果的にほとんど必ずエラーになる
```

### 境界パターン
複合パターンの除外パターン部分では、`^` という特殊な記号を使うことができます。
`^` が連続パターンの先頭に書かれた場合は、その連続パターンが生成し得る文字列から始まる文字列のみが除外されます (`^` がないと該当パターンが生成し得る文字列が途中に含まれているものが全て除外される)。
```
% "ab" | "ba" | "ca" - ^ "a" | "c";
# 「a」で始まるものか「c」を含むものが除外される
# 結果的に「ba」だけが生成される
```

`^` が連続パターンの末尾に書かれた場合は、その連続パターンが生成し得る文字列で終わる文字列のみが除外されます。
```
% "ab" | "ba" | "ca" - "a" ^;
# 「a」で終わるものが除外される
# 結果的に「ab」だけが生成される
```

`^` が連続パターンの先頭にも末尾に書かれた場合は、その連続パターンが生成し得る文字列と完全に一致する文字列のみが除外されます。
```
% "a" | "aa" | "aaa" - ^ "a" ^;
# 「a」のみが除外される
# 結果的に「aa」と「aaa」が等確率で生成される
```

この `^` は、生成されたパターンが除外されるかどうか調べるときに、文字列の前後の境界にマッチすると考えると分かりやすいかもしれません。

複合パターンの除外部分には任意のパターンが書けるので、もちろん変数パターンも使えます。
そこで、`^` を含むパターンを変数に定義しておいて、その変数を複合パターンの除外パターン部分で使うこともできます。
```
start_with_vowel = ^ ("a" | "e" | "i" | "o" | "u");
% "abc" | "def" | "ijk" | "uvw" - start_with_vowel;
# 「def」のみが生成される
```

なお、`^` は連続パターンの先頭か末尾にしか置くことはできません。
それ以外の場所 (連続パターンの内部など) に置くと構文エラーになります。
```
% "abc" | "bac" | "cab" - "a" ^ "c";  # 構文エラー
```

なお、`^` を複合パターンの除外部分以外にも書くこともできますが、その場合は単に無視されます。
```
% ^ "a" | "b" "c" ^;
# 「a」と「bc」が等確率で生成される
```

## より複雑な例
```
# 母音
short_vowel = "a" 5 | "e" 3 | "i" 2 | "o" 3 | "u" 2
long_vowel = short_vowel &1
vowel = short_vowel 3 | long_vowel
# 半母音＋母音
# 「yi」と「wu」と「wo」は半母音なしと区別が難しいので除外
svowel = vowel 3 | ("y" | "w") vowel - "yi" | "w" ("u" | "o")
# 子音
sz = "s" | "z"
td = "t" | "d"
kg = "k" | "g"
fv = "f" | "v"
cons = sz 3 | td 3 | kg 3 | fv 3 | ("n" | "h") 2
# 音節
V = svowel
CV = cons svowel
CVC = cons svowel cons
CVCC = cons svowel cons cons
CCVC = cons cons svowel cons
syll = V | CV 5 | CVC 3 | CVCC 3 | CCVC 2
# 読みづらい文字列
# 後で除外設定のために使う
hard_h = "h" cons | "h" ^
hard_cons = sz sz | td td | kg kg | fv fv | ("n" | "h") &1
hard = hard_h | hard_cons
# 単語
word = syll | syll syll 5 | syll syll syll 3 - hard
% word
```
生成例:
```
gyovsu, ezwiig, takzgyoozn, sef, fagnuuvd, saanvi, tagyeegva, nuukood
ido, gogag, fwakdho, saaoo, zaa, nwakiifek, hevznyud, nukwanookn
gago, zesgnuz, vuu, eesov, geenotzotf, dasu, seetg, twafzos
kod, naatfzo, hya, zata, dfyafti, vadzoog, vsyetnu, sakzfyeskegn
savyozwi, fiit, gugitaaf, kafgaz, hwesvtiifok, gizovz, sezfav, hyaava
```

## 形式的な構文定義
拡張した BNF 記法で記します。
以下の `zatlin` が Zatlin コードの全体の定義です。
```
zatlin ::= blankOrBreak sentence+ blankOrBreak eof
sentence ::= definition | mainPattern | comment
definition ::= identifier blank '=' blank compound blank semicolon
mainPattern ::= '%' blank compound blank semicolon
compound ::= disjunction (blank '-' blank disjunction)?
disjunction ::= weightedSequence (blank '|' blank weightedSequence)*
weightedSequence ::= sequence (blank weight)?
sequence ::= (circumflex blank)? sequencePattern (blank circumflex)?
sequencePattern ::= quote | backref | identifier | '(' blank compound blank ')'
quote ::= '"' (quoteEscape | quoteContent)* '"'
quoteEscape ::= '\\' ('u' [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] [A-Fa-f0-9] | '\\' | '"')
quoteContent ::= [^\\"]
backref ::= '&' [0-9]+
circumflex ::= '^'
comment ::= '#' [^\n]* blankOrBreak
semicolon ::= ';' blankOrBreak | break blankOrBreak | (?= '#' | eof)
identifier ::= [a-zA-Z] [a-zA-Z0-9_]*
weight ::= [0-9]+ '.'? [0-9]* | '.' [0-9]+
blankOrBreak ::= [\s]*
blank ::= [^\S\n]*
break ::= '\n'
```

拡張した記号は以下の通りです。

- `foo*` ･･･ `foo` の 0 回以上の繰り返し
- `foo+` ･･･ `foo` の 1 回以上の繰り返し
- `foo?` ･･･ `foo` の 0 回以上 1 回以下の繰り返し (`foo` は省略可能)
- `[0-9]` など ･･･ 正規表現の文字クラス
- `(?= foo)` ･･･ `foo` の先読み